/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./demo/src/main.ts":
/*!**************************!*\
  !*** ./demo/src/main.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/pipe2d */ \"./lib/pipe2d.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst cursorScale = 1.5;\nconst cursorCanvas = document.getElementById(\"cursor\");\ncursorCanvas.width *= cursorScale;\ncursorCanvas.height *= cursorScale;\nconst cursorCanvasContext = cursorCanvas.getContext(\"2d\");\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    // create a pipe that samples an image at given coordinates\n    // this will be used to draw the background\n    const backgroundImagePipe = yield (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.imagePipe)(\"bg.jpg\");\n    // ie, create a (scaled) cursor image pipe\n    const cursorImage = (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.scalePipe)(yield (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.imagePipe)(\"cursor.png\"), cursorScale);\n    // create a pipe that reads from a pixel pipe (usually an image pipe) and returns [number, number], to use as a displacement map\n    // this pipe reads the displacement image's red channel to determine horizontal displacement and green for vertical.\n    const cursorRefraction = (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.createDisplacementMap)((0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.scalePipe)(yield (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.imagePipe)(\"cursor-disp.png\"), cursorScale), cursorScale * 16);\n    let cursorX = -Infinity;\n    let cursorY = 1;\n    const cursorOverlayPipe = {\n        width: cursorImage.width,\n        height: cursorImage.height,\n        get(x, y) {\n            // grab the displacement values, relative to our cursor\n            const [displaceX, displaceY] = cursorRefraction.get(x, y);\n            // and the pixel from the cursor image\n            const cursorPixel = cursorImage.get(x, y);\n            // if there's no displacement here we may as well exit early\n            if ((displaceX == 0 && displaceY == 0))\n                return cursorPixel;\n            // adjust the background image to the current screen size\n            const backgroundPipe = (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.stretchPipe)(backgroundImagePipe, window.innerWidth, window.innerHeight);\n            // grab from backgroundPipe at the displaced coordinates\n            const backgroundPixel = backgroundPipe.get(x + cursorX - displaceX, y + cursorY + displaceY);\n            // draw the cursor image pixel on top, et voila, the pixel to display:\n            return (0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.applyPixel)(backgroundPixel, cursorPixel);\n        }\n    };\n    function render() {\n        // draw cursor to the overlay canvas:\n        cursorCanvasContext.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);\n        cursorCanvasContext.drawImage((0,_lib_pipe2d__WEBPACK_IMPORTED_MODULE_0__.renderRGBAPipeToCanvas)(cursorOverlayPipe), 0, 0);\n    }\n    render();\n    // the unremarkable stuff; create mouse events to update the cursor position\n    document.body.addEventListener(\"mousemove\", ev => {\n        cursorX = ev.clientX;\n        cursorY = ev.clientY;\n        cursorCanvas.style.left = cursorX + \"px\";\n        cursorCanvas.style.top = cursorY + \"px\";\n        render();\n    });\n    document.body.addEventListener(\"mouseleave\", () => {\n        cursorX = -Infinity;\n        render();\n    });\n}))();\n\n\n//# sourceURL=webpack://pipe2d/./demo/src/main.ts?");

/***/ }),

/***/ "./lib/pipe2d.ts":
/*!***********************!*\
  !*** ./lib/pipe2d.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   antialiasPipe: () => (/* binding */ antialiasPipe),\n/* harmony export */   applyPixel: () => (/* binding */ applyPixel),\n/* harmony export */   arrayPipeXY: () => (/* binding */ arrayPipeXY),\n/* harmony export */   arrayPipeYX: () => (/* binding */ arrayPipeYX),\n/* harmony export */   coordModPipe: () => (/* binding */ coordModPipe),\n/* harmony export */   createDisplacementMap: () => (/* binding */ createDisplacementMap),\n/* harmony export */   exportPipeFlatXY: () => (/* binding */ exportPipeFlatXY),\n/* harmony export */   exportPipeFlatYX: () => (/* binding */ exportPipeFlatYX),\n/* harmony export */   exportPipeXY: () => (/* binding */ exportPipeXY),\n/* harmony export */   exportPipeYX: () => (/* binding */ exportPipeYX),\n/* harmony export */   fadePipe: () => (/* binding */ fadePipe),\n/* harmony export */   flatArrayPipeXY: () => (/* binding */ flatArrayPipeXY),\n/* harmony export */   flatArrayPipeYX: () => (/* binding */ flatArrayPipeYX),\n/* harmony export */   floorPipe: () => (/* binding */ floorPipe),\n/* harmony export */   horizontalFlipPipe: () => (/* binding */ horizontalFlipPipe),\n/* harmony export */   imagePipe: () => (/* binding */ imagePipe),\n/* harmony export */   mapPipe: () => (/* binding */ mapPipe),\n/* harmony export */   offsetPipe: () => (/* binding */ offsetPipe),\n/* harmony export */   pipeSequence: () => (/* binding */ pipeSequence),\n/* harmony export */   renderRGBAPipeToCanvas: () => (/* binding */ renderRGBAPipeToCanvas),\n/* harmony export */   rotatePipe: () => (/* binding */ rotatePipe),\n/* harmony export */   scalePipe: () => (/* binding */ scalePipe),\n/* harmony export */   solidPipe: () => (/* binding */ solidPipe),\n/* harmony export */   stretchPipe: () => (/* binding */ stretchPipe),\n/* harmony export */   verticalFlipPipe: () => (/* binding */ verticalFlipPipe)\n/* harmony export */ });\nconst applyPixel = (from, to) => {\n    const toAlpha = to[3];\n    if (toAlpha == 0)\n        return from;\n    if (toAlpha == 1)\n        return to;\n    const fromRGB = from.slice(0, 3);\n    const toRGB = to.slice(0, 3);\n    const fromAlpha = from[3];\n    return [\n        blendNumbers(fromRGB[0], toRGB[0], toAlpha),\n        blendNumbers(fromRGB[1], toRGB[1], toAlpha),\n        blendNumbers(fromRGB[2], toRGB[2], toAlpha),\n        Math.max(fromAlpha, toAlpha),\n    ];\n};\nconst blendNumbers = (from, to, progress) => {\n    return from + progress * (to - from);\n};\nconst blendPixel = (from, to, progress) => {\n    if (progress == 0)\n        return from;\n    if (progress == 1)\n        return to;\n    return [\n        blendNumbers(from[0], to[0], progress),\n        blendNumbers(from[1], to[1], progress),\n        blendNumbers(from[2], to[2], progress),\n        blendNumbers(from[3], to[3], progress),\n    ];\n};\nfunction imagePipe(source, options = {}) {\n    if (typeof source == \"string\") {\n        const src = source;\n        return new Promise((resolve, reject) => {\n            const img = document.createElement(\"img\");\n            img.onload = () => resolve(imagePipe(img, options));\n            img.onerror = (e) => reject(e);\n            img.src = src;\n        });\n    }\n    const opts = Object.assign({ oob: [0, 0, 0, 0], nearest: false }, options);\n    if (source instanceof HTMLImageElement) {\n        const canvas = new OffscreenCanvas(source.naturalWidth, source.naturalHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(source, 0, 0);\n        source = canvas;\n    }\n    if (source instanceof HTMLCanvasElement\n        || source instanceof OffscreenCanvas)\n        source = source.getContext(\"2d\");\n    if (source instanceof CanvasRenderingContext2D\n        || source instanceof OffscreenCanvasRenderingContext2D)\n        source = source.getImageData(0, 0, source.canvas.width, source.canvas.height);\n    if (source instanceof ImageData) {\n        const data = [];\n        for (let i = 0; i < source.data.length; i += 4)\n            data.push([\n                source.data[i] / 255,\n                source.data[i + 1] / 255,\n                source.data[i + 2] / 255,\n                source.data[i + 3] / 255,\n            ]);\n        const nearestPipe = flatArrayPipeXY(data, source.width, source.height, opts.oob);\n        return opts.nearest\n            ? nearestPipe\n            : antialiasPipe(nearestPipe);\n    }\n    // Pipe2D<RGBA> source\n    return imagePipe(renderRGBAPipeToCanvas(source), options);\n}\n;\n/**\n * Renders a pipe to a two-dimensional array, with a T[x][y] layout\n * @param source\n * @returns\n */\nfunction exportPipeXY(source) {\n    const columns = [];\n    for (let x = 0; x < source.width; x++) {\n        const column = [];\n        columns.push(column);\n        for (let y = 0; y < source.height; y++) {\n            column.push(source.get(x, y));\n        }\n    }\n    return columns;\n}\n;\n/**\n * Renders a pipe to a two-dimensional array, with a T[y][x] layout\n * @param source\n * @returns\n */\nfunction exportPipeYX(source) {\n    return exportPipeXY(horizontalFlipPipe(rotatePipe(source, \"right\")));\n}\n;\n/**\n * Renders a pipe to a flat array, ordered as T[(0,0), (1,0)...]\n * @param source\n * @returns\n */\nfunction exportPipeFlatXY(source) {\n    const items = [];\n    for (let y = 0; y < source.height; y++) {\n        for (let x = 0; x < source.width; x++) {\n            items.push(source.get(x, y));\n        }\n    }\n    return items;\n}\n;\n/**\n * Renders a pipe to a flat array, ordered as T[(0,0), (0,1)...]\n * @param source\n * @returns\n */\nfunction exportPipeFlatYX(source) {\n    return exportPipeFlatXY(horizontalFlipPipe(rotatePipe(source, \"right\")));\n}\n;\nfunction renderRGBAPipeToCanvas(texture, target, dx = 0, dy = 0, dw = texture.width, dh = texture.height) {\n    if (typeof target == \"number\") {\n        dw = target;\n        dh = dx;\n        target = undefined;\n    }\n    if (!target) {\n        const canvas = new OffscreenCanvas(texture.width, texture.height);\n        renderRGBAPipeToCanvas(texture, canvas, dx, dy, dw, dh);\n        return canvas;\n    }\n    if (target instanceof ImageData) {\n        for (let x = 0; x < target.width; x++) {\n            const px = Math.floor((x / target.width) * texture.width);\n            for (let y = 0; y < target.height; y++) {\n                const idx = (y * target.width + x) * 4;\n                const py = Math.floor((y / target.height) * texture.height);\n                const pixel = texture.get(px, py);\n                target.data[idx] = pixel[0] * 255;\n                target.data[idx + 1] = pixel[1] * 255;\n                target.data[idx + 2] = pixel[2] * 255;\n                target.data[idx + 3] = pixel[3] * 255;\n            }\n        }\n        return;\n    }\n    const canvasContext = (target instanceof CanvasRenderingContext2D\n        || target instanceof OffscreenCanvasRenderingContext2D) ? target : target.getContext(\"2d\");\n    const imageData = canvasContext.createImageData(dw, dh);\n    renderRGBAPipeToCanvas(texture, imageData);\n    canvasContext.putImageData(imageData, dx, dy);\n}\n;\nfunction pipeSequence(sources) {\n    const [width, height] = sources.reduce((pr, p) => [\n        Math.max(pr[0], p.width),\n        Math.max(pr[1], p.height)\n    ], [0, 0]);\n    return {\n        width, height,\n        get(x, y) {\n            return sources.reduce((r, p) => applyPixel(r, p.get(x, y)), [0, 0, 0, 0]);\n        }\n    };\n}\nfunction offsetPipe(source, offsetX, offsetY) {\n    return {\n        width: source.width + offsetX,\n        height: source.height + offsetY,\n        get(x, y) {\n            return source.get(x - offsetX, y - offsetY);\n        }\n    };\n}\n;\nfunction createDisplacementMap(source, strength = 5) {\n    return {\n        width: source.width,\n        height: source.height,\n        get: (x, y) => {\n            const px = source.get(x, y);\n            return [(px[0] - .5) * strength * px[3], (px[1] - .5) * strength * px[3]];\n        }\n    };\n}\n;\nfunction coordModPipe(source, coordMod) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            const [mx, my] = coordMod(x, y);\n            return source.get(mx, my);\n        }\n    };\n}\n;\nfunction floorPipe(source) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            return source.get(Math.floor(x), Math.floor(y));\n        }\n    };\n}\n;\nfunction scalePipe(source, scaleX, scaleY = scaleX) {\n    return {\n        width: Math.round(source.width * scaleX),\n        height: Math.round(source.height * scaleY),\n        get(x, y) {\n            return source.get(x / scaleX, y / scaleY);\n        }\n    };\n}\n;\nfunction fadePipe(source, alpha) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            const px = source.get(x, y);\n            return [px[0], px[1], px[2], px[3] * alpha];\n        }\n    };\n}\n;\nfunction horizontalFlipPipe(source) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            return source.get(source.width - x, y);\n        }\n    };\n}\n;\nfunction verticalFlipPipe(source) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            return source.get(x, source.height - y);\n        }\n    };\n}\n;\nfunction rotatePipe(source, direction) {\n    return {\n        width: direction == \"over\" ? source.width : source.height,\n        height: direction == \"over\" ? source.height : source.width,\n        get: {\n            left: (x, y) => {\n                return source.get(source.width - y, x);\n            },\n            right: (x, y) => {\n                return source.get(y, source.height - x);\n            },\n            over: (x, y) => {\n                return source.get(source.width - x, source.height - y);\n            }\n        }[direction],\n    };\n}\n;\nfunction mapPipe(source, mapFunc) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            return mapFunc(source.get(x, y));\n        },\n    };\n}\n;\nfunction solidPipe(value, width = 0, height = 0, oob = value) {\n    return {\n        width,\n        height,\n        get: oob == value\n            ? (_x, _y) => value\n            : (x, y) => {\n                return (x >= 0 && y >= 0 && x <= width - 1 && y <= height - 1)\n                    ? value\n                    : oob;\n            }\n    };\n}\n;\nfunction stretchPipe(source, newWidth, newHeight) {\n    const ratioX = newWidth / source.width;\n    const ratioY = newHeight / source.height;\n    return {\n        width: newWidth,\n        height: newHeight,\n        get(x, y) {\n            return source.get(x / ratioX, y / ratioY);\n        }\n    };\n}\n;\nfunction arrayPipe(source, width, height, fallback, yx) {\n    return {\n        width, height,\n        get(x, y) {\n            if (x < 0 || y < 0 || x >= width || y >= height)\n                return fallback;\n            [x, y] = yx ? [Math.floor(y), Math.floor(x)] : [Math.floor(x), Math.floor(y)];\n            const column = source[x];\n            if (!column)\n                return fallback;\n            const item = column[y];\n            return item === undefined ? fallback : item;\n        }\n    };\n}\n;\nfunction arrayPipeXY(source, width, height, fallback) {\n    return arrayPipe(source, width, height, fallback, false);\n}\n;\nfunction arrayPipeYX(source, width, height, fallback) {\n    return arrayPipe(source, width, height, fallback, true);\n}\n;\nfunction flatArrayPipe(source, width, height, fallback, vertical) {\n    return {\n        width, height,\n        get(x, y) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n            if (x < 0 || y < 0 || x >= width || y >= height)\n                return fallback;\n            const item = source[vertical ? x * height + y : y * width + x];\n            return item === undefined ? fallback : item;\n        }\n    };\n}\n;\nfunction flatArrayPipeXY(source, width, height, fallback) {\n    return flatArrayPipe(source, width, height, fallback, false);\n}\n;\nfunction flatArrayPipeYX(source, width, height, fallback) {\n    return flatArrayPipe(source, width, height, fallback, true);\n}\n;\nfunction antialiasPipe(source) {\n    return {\n        width: source.width,\n        height: source.height,\n        get(x, y) {\n            x += .5;\n            y += .5;\n            const px = source.get(x, y);\n            if (y % 1 == 0 && x % 1 == 0)\n                return px;\n            const right = blendPixel(px, source.get(x + 1, y), x % 1);\n            const down = blendPixel(px, source.get(x, y + 1), y % 1);\n            return blendPixel(right, down, .5);\n        }\n    };\n}\n;\n\n\n//# sourceURL=webpack://pipe2d/./lib/pipe2d.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/src/main.ts");
/******/ 	
/******/ })()
;